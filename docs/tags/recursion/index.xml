<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursion on Programmer</title>
    <link>https://shahprincea.github.io/leonidas/tags/recursion/</link>
    <description>Recent content in recursion on Programmer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shahprincea.github.io/leonidas/tags/recursion/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Combination of the list</title>
      <link>https://shahprincea.github.io/leonidas/post/combination-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/combination-list/</guid>
      <description>Combination of the number  Algo : Divide and Conquer Time complexity : O(2^(n)) since at each stage you have two choices either pick an item or not to pick an item. Space Complexity : O(n)  public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; powerSet(List&amp;lt;Integer&amp;gt; list) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(); if(list == null || list.isEmpty()) return lists; helper(list, lists, new ArrayList&amp;lt;Integer&amp;gt;(), 0); return lists; } public static void helper(List&amp;lt;Integer&amp;gt; list, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; lists, ArrayList&amp;lt;Integer&amp;gt; tmp, int start) { lists.</description>
    </item>
    
    <item>
      <title>Permutation of the List</title>
      <link>https://shahprincea.github.io/leonidas/post/permutation-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/permutation-list/</guid>
      <description>Permutation of the List Given list of numbers return all its permutation. One way to understand this is to draw a tree for small list.
The high level logic is to print all the permutation with first number lock. Then go into recursion and lock second position and print all its permutation and so on.
Base case is when start point reaches the size().
 Algo : Divide and Conquer Time complexity : O(n!</description>
    </item>
    
    <item>
      <title>Permutation of the string</title>
      <link>https://shahprincea.github.io/leonidas/post/permutation-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/permutation-string/</guid>
      <description>Permutation of the String Given a string return all its permutation. One way to understand this is to draw a tree for small string.
The high level logic is to print all the permutation with first character lock. Then go into recursion and lock second position and print all its permutation and so on.
Base case is when start point reaches the length of the input string.
 Algo : Recursion Time complexity : O(n!</description>
    </item>
    
  </channel>
</rss>