<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programmer</title>
    <link>https://shahprincea.github.io/leonidas/</link>
    <description>Recent content on Programmer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shahprincea.github.io/leonidas/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Heap Sort</title>
      <link>https://shahprincea.github.io/leonidas/post/heap-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/heap-sort/</guid>
      <description> Sorting Merge sort is comparison based sorting.
 Algo : Divide and Conquer Time complexity : O(nlog(n)) Space Complexity : O(n)
public void mergeSort(int[] arr) { //Error handling if(arr == null || arr.length == 0) return; int[] aux = new int[arr.length];	mergeSort(arr, aux, 0, arr.length-1);	} public void mergeSort(int[] arr, int[] aux, int left, int right) { if(left &amp;lt; right) { int mid = left + (right - left)/2; //Divide mergeSort(arr, aux, left, mid); mergeSort(arr, aux, mid+1, right); merge(arr, aux, left, mid, right); } } //Merge two sorted array public void merge(int[] arr, int[] aux, int left, int mid, int right) { int i = left, j = mid + 1, k = left; while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt; arr[j]) aux[k] = arr[i++]; else aux[k] = arr[j++]; k++; } while(i &amp;lt;= mid) { aux[k++] = arr[i++]; } while(j &amp;lt;= right) { aux[k++] = arr[j++]; } for(int p = left; p &amp;lt;= right; p++) { arr[p] = aux[p]; } }   </description>
    </item>
    
    <item>
      <title>Linear Sort</title>
      <link>https://shahprincea.github.io/leonidas/post/count-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/count-sort/</guid>
      <description> Sorting Merge sort is comparison based sorting.
 Algo : Divide and Conquer Time complexity : O(nlog(n)) Space Complexity : O(n)
public void mergeSort(int[] arr) { //Error handling if(arr == null || arr.length == 0) return; int[] aux = new int[arr.length];	mergeSort(arr, aux, 0, arr.length-1);	} public void mergeSort(int[] arr, int[] aux, int left, int right) { if(left &amp;lt; right) { int mid = left + (right - left)/2; //Divide mergeSort(arr, aux, left, mid); mergeSort(arr, aux, mid+1, right); merge(arr, aux, left, mid, right); } } //Merge two sorted array public void merge(int[] arr, int[] aux, int left, int mid, int right) { int i = left, j = mid + 1, k = left; while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt; arr[j]) aux[k] = arr[i++]; else aux[k] = arr[j++]; k++; } while(i &amp;lt;= mid) { aux[k++] = arr[i++]; } while(j &amp;lt;= right) { aux[k++] = arr[j++]; } for(int p = left; p &amp;lt;= right; p++) { arr[p] = aux[p]; } }   </description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://shahprincea.github.io/leonidas/post/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/merge-sort/</guid>
      <description> Sorting Merge sort is comparison based sorting.
 Algo : Divide and Conquer Time complexity : O(nlog(n)) Space Complexity : O(n)
public void mergeSort(int[] arr) { //Error handling if(arr == null || arr.length == 0) return; int[] aux = new int[arr.length];	mergeSort(arr, aux, 0, arr.length-1);	} public void mergeSort(int[] arr, int[] aux, int left, int right) { if(left &amp;lt; right) { int mid = left + (right - left)/2; //Divide mergeSort(arr, aux, left, mid); mergeSort(arr, aux, mid+1, right); merge(arr, aux, left, mid, right); } } //Merge two sorted array public void merge(int[] arr, int[] aux, int left, int mid, int right) { int i = left, j = mid + 1, k = left; while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt; arr[j]) aux[k] = arr[i++]; else aux[k] = arr[j++]; k++; } while(i &amp;lt;= mid) { aux[k++] = arr[i++]; } while(j &amp;lt;= right) { aux[k++] = arr[j++]; } for(int p = left; p &amp;lt;= right; p++) { arr[p] = aux[p]; } }   </description>
    </item>
    
    <item>
      <title>Permutation of the List</title>
      <link>https://shahprincea.github.io/leonidas/post/permutation-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/permutation-list/</guid>
      <description>Permutation of the List Given list of numbers return all its permutation. One way to understand this is to draw a tree for small list.
The high level logic is to print all the permutation with first number lock. Then go into recursion and lock second position and print all its permutation and so on.
Base case is when start point reaches the size().
public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permutation(List&amp;lt;Integer&amp;gt; list) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(); //Error Handling if(list == null || list.</description>
    </item>
    
    <item>
      <title>Permutation of the string</title>
      <link>https://shahprincea.github.io/leonidas/post/permutation-string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/permutation-string/</guid>
      <description>Permutation of the String Given a string return all its permutation. One way to understand this is to draw a tree for small string.
The high level logic is to print all the permutation with first character lock. Then go into recursion and lock second position and print all its permutation and so on.
Base case is when start point reaches the length of the input string.
public List&amp;lt;String&amp;gt; permutation(String str) { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); if(str == null || str.</description>
    </item>
    
    <item>
      <title>Quick Sort</title>
      <link>https://shahprincea.github.io/leonidas/post/quick-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shahprincea.github.io/leonidas/post/quick-sort/</guid>
      <description> Sorting Merge sort is comparison based sorting.
 Algo : Divide and Conquer Time complexity : O(nlog(n)) Space Complexity : O(n)
public void mergeSort(int[] arr) { //Error handling if(arr == null || arr.length == 0) return; int[] aux = new int[arr.length];	mergeSort(arr, aux, 0, arr.length-1);	} public void mergeSort(int[] arr, int[] aux, int left, int right) { if(left &amp;lt; right) { int mid = left + (right - left)/2; //Divide mergeSort(arr, aux, left, mid); mergeSort(arr, aux, mid+1, right); merge(arr, aux, left, mid, right); } } //Merge two sorted array public void merge(int[] arr, int[] aux, int left, int mid, int right) { int i = left, j = mid + 1, k = left; while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt; arr[j]) aux[k] = arr[i++]; else aux[k] = arr[j++]; k++; } while(i &amp;lt;= mid) { aux[k++] = arr[i++]; } while(j &amp;lt;= right) { aux[k++] = arr[j++]; } for(int p = left; p &amp;lt;= right; p++) { arr[p] = aux[p]; } }   </description>
    </item>
    
  </channel>
</rss>